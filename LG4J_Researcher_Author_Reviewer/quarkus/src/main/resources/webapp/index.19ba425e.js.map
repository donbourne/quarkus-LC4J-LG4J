{"mappings":"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","sources":["<anon>","src/lg4j-executor.js","src/lg4j-executor-test.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $hNeh9 = parcelRequire(\"hNeh9\");\n\nvar $800sp = parcelRequire(\"800sp\");\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData\n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */ /**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $fe8cbfd9ee8314da$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nconst $fe8cbfd9ee8314da$export$749baee93d8a648e = {\n    /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */ callInit: async (elem)=>{\n        /** @typedef {InitData} */ const detail = {\n            threads: [\n                [\n                    'default',\n                    []\n                ]\n            ],\n            title: 'LangGraph4j : TEST',\n            args: [\n                {\n                    name: 'input',\n                    type: 'STRING',\n                    required: true\n                }\n            ],\n            graph: `\n---\ntitle: TEST\n---        \nflowchart TD\n  start((start))\n  stop((stop))\n  web_search(\"web_search\")\n  retrieve(\"retrieve\")\n  grade_documents(\"grade_documents\")\n  generate(\"generate\")\n  transform_query(\"transform_query\")\n  start:::start -->|web_search| web_search:::web_search\n  start:::start -->|vectorstore| retrieve:::retrieve\n  web_search:::web_search --> generate:::generate\n  retrieve:::retrieve --> grade_documents:::grade_documents\n  grade_documents:::grade_documents -->|transform_query| transform_query:::transform_query\n  grade_documents:::grade_documents -->|generate| generate:::generate\n  transform_query:::transform_query --> retrieve:::retrieve\n  generate:::generate -->|not supported| generate:::generate\n  generate:::generate -->|not useful| transform_query:::transform_query\n  generate:::generate -->|useful| stop:::stop\n      `\n        };\n        await $fe8cbfd9ee8314da$var$delay(1000);\n        /** @typedef {CustomEvent<InitData>} */ const event = new CustomEvent('init', {\n            detail: detail,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        });\n        elem.dispatchEvent(event);\n        // @ts-ignore\n        return detail;\n    },\n    /**\n   * @param   {HTMLElement}  elem\n   * @param   {string|undefined}  selectedThread \n   */ callSubmitAction: async (elem, selectedThread)=>{\n        const thread = selectedThread;\n        const send = async (/** @type {string} */ nodeId)=>{\n            /** @typedef {ResultData} */ const detail = [\n                thread,\n                {\n                    checkpoint: nodeId === 'start' || nodeId === 'stop' ? undefined : `checkpoint-${nodeId}`,\n                    node: nodeId,\n                    state: {\n                        input: \"this is input\",\n                        property1: {\n                            value: \"value1\",\n                            valid: true\n                        },\n                        property2: {\n                            value: \"value2\",\n                            children: {\n                                elements: [\n                                    1,\n                                    2,\n                                    3\n                                ]\n                            }\n                        }\n                    }\n                }\n            ];\n            /** @typedef {CustomEvent<ResultData>} */ const event = new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            });\n            await $fe8cbfd9ee8314da$var$delay(1000);\n            elem.dispatchEvent(event);\n        };\n        await send('start');\n        await send('retrieve');\n        await send('grade_documents');\n        await send('transform_query');\n        await send('retrieve');\n        await send('grade_documents');\n        await send('generate');\n        await send('stop');\n    }\n};\nconst $fe8cbfd9ee8314da$export$b5b93dd066d67af9 = {\n    /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */ callInit: async (elem)=>{\n        /** @typedef {InitData} */ const detail = {\n            threads: [\n                [\n                    'default',\n                    []\n                ]\n            ],\n            title: 'LangGraph4j : TEST',\n            args: [\n                {\n                    name: 'input',\n                    type: 'IMAGE',\n                    required: true\n                }\n            ],\n            graph: `\n---\ntitle: Image to diagram with correction\n---\nflowchart TD\n\t__START__((start))\n\t__END__((stop))\n\tagent_describer(\"agent_describer\")\n\tagent_sequence_plantuml(\"agent_sequence_plantuml\")\n\tagent_generic_plantuml(\"agent_generic_plantuml\")\nsubgraph evaluate_result\n\t___START__((start)):::___START__\n\t___END__((stop)):::___END__\n\t_evaluate_result(\"evaluate_result\")\n\t_agent_review(\"agent_review\")\n\t%%\t_condition1{\"check state\"}\n\t___START__:::___START__ --> _evaluate_result:::_evaluate_result\n\t_agent_review:::_agent_review --> _evaluate_result:::_evaluate_result\n\t%%\t_evaluate_result:::_evaluate_result --> _condition1:::_condition1\n\t%%\t_condition1:::_condition1 -->|ERROR| _agent_review:::_agent_review\n\t_evaluate_result:::_evaluate_result -->|ERROR| _agent_review:::_agent_review\n\t%%\t_condition1:::_condition1 -->|UNKNOWN| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|UNKNOWN| ___END__:::___END__\n\t%%\t_condition1:::_condition1 -->|OK| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|OK| ___END__:::___END__\nend\n\t%%\tcondition1{\"check state\"}\n\t__START__:::__START__ --> agent_describer:::agent_describer\n\t%%\tagent_describer:::agent_describer --> condition1:::condition1\n\t%%\tcondition1:::condition1 -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\tagent_describer:::agent_describer -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\t%%\tcondition1:::condition1 -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_describer:::agent_describer -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_sequence_plantuml:::agent_sequence_plantuml --> evaluate_result:::evaluate_result\n\tagent_generic_plantuml:::agent_generic_plantuml --> evaluate_result:::evaluate_result\n\tevaluate_result:::evaluate_result --> __END__:::__END__\n\n\tclassDef ___START__ fill:black,stroke-width:1px,font-size:xx-small;\n\tclassDef ___END__ fill:black,stroke-width:1px,font-size:xx-small;\n  `\n        };\n        await $fe8cbfd9ee8314da$var$delay(1000);\n        /** @typedef {CustomEvent<InitData>} */ const event = new CustomEvent('init', {\n            detail: detail,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        });\n        elem.dispatchEvent(event);\n        // @ts-ignore\n        return detail;\n    },\n    /**\n  * @param   {HTMLElement}  elem\n  * @param   {string|undefined}  selectedThread \n  */ callSubmitAction: async (elem, selectedThread)=>{\n        const thread = selectedThread;\n        const send = async (/** @type {string} */ nodeId)=>{\n            /** @typedef {ResultData} */ const detail = [\n                thread,\n                {\n                    checkpoint: nodeId === 'start' || nodeId === 'stop' ? undefined : `checkpoint-${nodeId}`,\n                    node: nodeId,\n                    state: {\n                        input: \"this is input\",\n                        property1: {\n                            value: \"value1\",\n                            valid: true\n                        },\n                        property2: {\n                            value: \"value2\",\n                            children: {\n                                elements: [\n                                    1,\n                                    2,\n                                    3\n                                ]\n                            }\n                        }\n                    }\n                }\n            ];\n            /** @typedef {CustomEvent<ResultData>} */ const event = new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            });\n            await $fe8cbfd9ee8314da$var$delay(1000);\n            elem.dispatchEvent(event);\n        };\n        await send('__START__');\n        await send('agent_describer');\n        await send('agent_generic_plantuml');\n        await send('___START__');\n        await send('_evaluate_result');\n        await send('___END__');\n        await send('__END__');\n    }\n};\n\n\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */ /**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $0ca21e1f1d158660$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */ async function* $0ca21e1f1d158660$var$streamingResponse(response) {\n    // Attach Reader\n    const reader = response.body?.getReader();\n    while(reader){\n        // wait for next encoded chunk\n        const { done: done, value: value } = await reader.read();\n        // check if stream is done\n        if (done) break;\n        // Decodes data chunk and yields it\n        yield new TextDecoder().decode(value);\n    }\n}\nclass $0ca21e1f1d158660$export$2fe88ce002d9c04f extends (0, $800sp.LitElement) {\n    /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */ static styles = [\n        (0, $hNeh9.default),\n        (0, $800sp.css)`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `\n    ];\n    /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */ static properties = {\n        url: {\n            type: String,\n            reflect: true\n        },\n        test: {\n            type: Boolean,\n            reflect: true\n        },\n        _executing: {\n            state: true\n        }\n    };\n    /**\n   * @type {string | null }\n   */ url = null;\n    /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */ #selectedThread;\n    /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */ #updatedState = null;\n    /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */ constructor(){\n        super();\n        this.test = false;\n        /** @type {ArgumentMetadata[]} */ this.formMetaData = [];\n        this._executing = false;\n    }\n    /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */ #onThreadUpdated(e) {\n        console.debug('thread-updated', e.detail);\n        this.#selectedThread = e.detail;\n        this.#updatedState = null;\n        this.requestUpdate();\n    }\n    /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */ #onNodeUpdated(e) {\n        console.debug('onNodeUpdated', e);\n        this.#updatedState = e.detail;\n        this.requestUpdate();\n    }\n    /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */ connectedCallback() {\n        super.connectedCallback();\n        // @ts-ignore\n        this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.addEventListener('node-updated', this.#onNodeUpdated);\n        if (this.test) {\n            (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callInit(this).then((data)=>{\n                this.formMetaData = data.args;\n                this.requestUpdate();\n            });\n            return;\n        }\n        this.#callInit();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        // @ts-ignore\n        this.removeEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.removeEventListener('node-updated', this.#onNodeUpdated);\n    }\n    /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */ render() {\n        // console.debug( 'render', this.formMetaData )\n        return (0, $800sp.html)`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name: name, type: type })=>{\n            switch(type){\n                case 'STRING':\n                    return (0, $800sp.html)`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`;\n                case 'IMAGE':\n                    return (0, $800sp.html)`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`;\n            }\n        })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        `;\n    }\n    async #callInit() {\n        const initResponse = await fetch(`${this.url}/init`);\n        /** @type {InitData} */ const initData = await initResponse.json();\n        console.debug('initData', initData);\n        this.dispatchEvent(new CustomEvent('init', {\n            detail: initData,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.formMetaData = initData.args;\n        // this.#nodes = initData.nodes\n        this.requestUpdate();\n    }\n    async #callResume() {\n        this._executing = true;\n        try {\n            if (this.test) {\n                await (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callSubmitAction(this, this.#selectedThread);\n                return;\n            }\n            await this.#callResumeAction();\n        } finally{\n            this._executing = false;\n        }\n    }\n    async #callResumeAction() {\n        const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(this.#updatedState?.data)\n        });\n        this.#updatedState = null;\n        for await (let chunk of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            console.debug(chunk);\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: JSON.parse(chunk),\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n    }\n    async #callSubmit() {\n        this._executing = true;\n        try {\n            if (this.test) {\n                await (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callSubmitAction(this, this.#selectedThread);\n                return;\n            }\n            await this.#callSubmitAction();\n        } finally{\n            this._executing = false;\n        }\n    }\n    async #callSubmitAction() {\n        // Get input as object\n        /** @type { Record<string,any> } */ const result = {};\n        /** @type { Record<string,any> } data */ const data = this.formMetaData.reduce((acc, md)=>{\n            const { name: name, type: type } = md;\n            const elem = this.shadowRoot?.getElementById(name);\n            switch(type){\n                case 'STRING':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n                case 'IMAGE':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n            }\n            return acc;\n        }, result);\n        const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        for await (let chunk of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            console.debug(chunk);\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: JSON.parse(chunk),\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n    }\n}\nwindow.customElements.define('lg4j-executor', $0ca21e1f1d158660$export$2fe88ce002d9c04f);\n\n\n//# sourceMappingURL=index.19ba425e.js.map\n","\nimport TWStyles from './twlit.js';\n\nimport { html, css, LitElement, CSSResult } from 'lit';\n\nimport { imageToDiagram as test } from './lg4j-executor-test.js';\n\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */\nasync function* streamingResponse(response) {\n  // Attach Reader\n  const reader = response.body?.getReader();\n\n  while (true && reader) {\n    // wait for next encoded chunk\n    const { done, value } = await reader.read();\n    // check if stream is done\n    if (done) break;\n    // Decodes data chunk and yields it\n    yield (new TextDecoder().decode(value));\n  }\n}\n\n/**\n * LG4JInputElement is a custom web component that extends LitElement.\n * It provides a styled input container with a placeholder.\n * \n * @class\n * @extends {LitElement}\n */\nexport class LG4JExecutorElement extends LitElement {\n\n  /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */\n  static styles = [TWStyles, css`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `];\n\n\n  /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */\n  static properties = {\n    url: { type: String, reflect: true },\n    test: { type: Boolean, reflect: true },\n    _executing: { state: true }\n\n  }\n\n  /**\n   * @type {string | null }\n   */\n  url = null\n\n  /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */\n  #selectedThread\n\n  /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */\n  #updatedState = null\n\n\n  /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */\n  constructor() {\n    super();\n    this.test = false\n    /** @type {ArgumentMetadata[]} */\n    this.formMetaData = []\n    this._executing = false\n\n  }\n\n  /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */\n  #onThreadUpdated(e) {\n    console.debug('thread-updated', e.detail)\n    this.#selectedThread = e.detail\n    this.#updatedState = null\n    this.requestUpdate()\n  }\n\n  /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */\n  #onNodeUpdated(e) {\n    console.debug('onNodeUpdated', e)\n    this.#updatedState = e.detail\n    this.requestUpdate()\n  }\n\n  /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    // @ts-ignore\n    this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n    // @ts-ignore\n    this.addEventListener('node-updated', this.#onNodeUpdated)\n\n    if (this.test) {\n      test.callInit(this)\n        .then(data => {\n          this.formMetaData = data.args \n          this.requestUpdate()\n        })\n      return\n    }\n\n    this.#callInit()\n\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    // @ts-ignore\n    this.removeEventListener(\"thread-updated\", this.#onThreadUpdated)\n    // @ts-ignore\n    this.removeEventListener('node-updated', this.#onNodeUpdated)\n\n  }\n\n  /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */\n  render() {\n\n    // console.debug( 'render', this.formMetaData )\n    return html`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name, type }) => {\n      switch (type) {\n        case 'STRING':\n          return html`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`\n        case 'IMAGE':\n          return html`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`\n      }\n    })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        `;\n  }\n\n  async #callInit() {\n\n    const initResponse = await fetch(`${this.url}/init`)\n\n    /** @type {InitData} */\n    const initData = await initResponse.json()\n\n    console.debug('initData', initData);\n\n    this.dispatchEvent(new CustomEvent('init', {\n      detail: initData,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n    this.formMetaData = initData.args\n    // this.#nodes = initData.nodes\n    this.requestUpdate()\n  }\n\n  async #callResume() {\n    this._executing = true\n    try {\n\n      if (this.test) {\n        await test.callSubmitAction(this, this.#selectedThread);\n        return\n      }\n\n      await this.#callResumeAction()\n\n\n    }\n    finally {\n      this._executing = false\n    }\n\n  }\n\n  async #callResumeAction() {\n\n    const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n      method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(this.#updatedState?.data)\n    });\n\n    this.#updatedState = null\n\n    for await (let chunk of streamingResponse(execResponse)) {\n      console.debug(chunk)\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail: JSON.parse(chunk),\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n\n    }\n\n\n  }\n\n  async #callSubmit() {\n\n    this._executing = true\n    try {\n\n      if (this.test) {\n        await test.callSubmitAction(this, this.#selectedThread);\n        return\n      }\n\n      await this.#callSubmitAction()\n\n    }\n    finally {\n      this._executing = false\n    }\n  }\n\n  async #callSubmitAction() {\n\n    // Get input as object\n    /** @type { Record<string,any> } */\n    const result = {}\n    /** @type { Record<string,any> } data */\n    const data = this.formMetaData.reduce((acc, md) => {\n\n      const { name, type } = md\n      const elem = this.shadowRoot?.getElementById(name)\n\n      switch (type) {\n        case 'STRING':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n        case 'IMAGE':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n      }\n\n      return acc\n    }, result);\n\n    const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}`, {\n      method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n\n    for await (let chunk of streamingResponse(execResponse)) {\n      console.debug(chunk)\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail: JSON.parse(chunk),\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n\n    }\n\n  }\n\n}\n\nwindow.customElements.define('lg4j-executor', LG4JExecutorElement);\n","\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData\n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\nexport const adaptiveRAG = {\n  /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */\n  callInit: async (elem) => {\n\n    /** @typedef {InitData} */\n    const detail = {\n      threads: [['default', []]],\n      title: 'LangGraph4j : TEST',\n      args: [\n        { name: 'input', type: 'STRING', required: true }\n      ],\n      graph: `\n---\ntitle: TEST\n---        \nflowchart TD\n  start((start))\n  stop((stop))\n  web_search(\"web_search\")\n  retrieve(\"retrieve\")\n  grade_documents(\"grade_documents\")\n  generate(\"generate\")\n  transform_query(\"transform_query\")\n  start:::start -->|web_search| web_search:::web_search\n  start:::start -->|vectorstore| retrieve:::retrieve\n  web_search:::web_search --> generate:::generate\n  retrieve:::retrieve --> grade_documents:::grade_documents\n  grade_documents:::grade_documents -->|transform_query| transform_query:::transform_query\n  grade_documents:::grade_documents -->|generate| generate:::generate\n  transform_query:::transform_query --> retrieve:::retrieve\n  generate:::generate -->|not supported| generate:::generate\n  generate:::generate -->|not useful| transform_query:::transform_query\n  generate:::generate -->|useful| stop:::stop\n      `\n    }\n\n    await delay(1000);\n\n    /** @typedef {CustomEvent<InitData>} */\n    const event = new CustomEvent('init', {\n      detail,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    });\n\n\n    elem.dispatchEvent(event);\n\n    // @ts-ignore\n    return detail;\n  },\n\n\n  /**\n   * @param   {HTMLElement}  elem\n   * @param   {string|undefined}  selectedThread \n   */\n  callSubmitAction: async (elem, selectedThread) => {\n\n    const thread = selectedThread\n\n    const send = async ( /** @type {string} */ nodeId) => {\n\n      /** @typedef {ResultData} */\n      const detail = [thread, {\n        checkpoint: (nodeId === 'start' || nodeId === 'stop') ? undefined : `checkpoint-${nodeId}`,\n        node: nodeId,\n        state: {\n          input: \"this is input\",\n          property1: { value: \"value1\", valid: true },\n          property2: { value: \"value2\", children: { elements: [1, 2, 3] } }\n        }\n      }\n      ]\n\n      /** @typedef {CustomEvent<ResultData>} */\n      const event = new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      });\n\n      await delay(1000);\n      elem.dispatchEvent(event);\n    }\n\n    await send('start');\n    await send('retrieve');\n    await send('grade_documents');\n    await send('transform_query');\n    await send('retrieve');\n    await send('grade_documents');\n    await send('generate');\n    await send('stop');\n\n  }\n\n};\n\nexport const imageToDiagram = {\n  /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */\n  callInit: async (elem) => {\n\n    /** @typedef {InitData} */\n    const detail = {\n      threads: [['default', []]],\n      title: 'LangGraph4j : TEST',\n      args: [\n        { name: 'input', type: 'IMAGE', required: true }\n      ],\n      graph: `\n---\ntitle: Image to diagram with correction\n---\nflowchart TD\n\t__START__((start))\n\t__END__((stop))\n\tagent_describer(\"agent_describer\")\n\tagent_sequence_plantuml(\"agent_sequence_plantuml\")\n\tagent_generic_plantuml(\"agent_generic_plantuml\")\nsubgraph evaluate_result\n\t___START__((start)):::___START__\n\t___END__((stop)):::___END__\n\t_evaluate_result(\"evaluate_result\")\n\t_agent_review(\"agent_review\")\n\t%%\t_condition1{\"check state\"}\n\t___START__:::___START__ --> _evaluate_result:::_evaluate_result\n\t_agent_review:::_agent_review --> _evaluate_result:::_evaluate_result\n\t%%\t_evaluate_result:::_evaluate_result --> _condition1:::_condition1\n\t%%\t_condition1:::_condition1 -->|ERROR| _agent_review:::_agent_review\n\t_evaluate_result:::_evaluate_result -->|ERROR| _agent_review:::_agent_review\n\t%%\t_condition1:::_condition1 -->|UNKNOWN| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|UNKNOWN| ___END__:::___END__\n\t%%\t_condition1:::_condition1 -->|OK| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|OK| ___END__:::___END__\nend\n\t%%\tcondition1{\"check state\"}\n\t__START__:::__START__ --> agent_describer:::agent_describer\n\t%%\tagent_describer:::agent_describer --> condition1:::condition1\n\t%%\tcondition1:::condition1 -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\tagent_describer:::agent_describer -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\t%%\tcondition1:::condition1 -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_describer:::agent_describer -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_sequence_plantuml:::agent_sequence_plantuml --> evaluate_result:::evaluate_result\n\tagent_generic_plantuml:::agent_generic_plantuml --> evaluate_result:::evaluate_result\n\tevaluate_result:::evaluate_result --> __END__:::__END__\n\n\tclassDef ___START__ fill:black,stroke-width:1px,font-size:xx-small;\n\tclassDef ___END__ fill:black,stroke-width:1px,font-size:xx-small;\n  `\n    }\n\n    await delay(1000);\n\n    /** @typedef {CustomEvent<InitData>} */\n    const event = new CustomEvent('init', {\n      detail,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    });\n\n    elem.dispatchEvent(event);\n\n    // @ts-ignore\n    return detail\n  },\n\n\n  /**\n  * @param   {HTMLElement}  elem\n  * @param   {string|undefined}  selectedThread \n  */\n  callSubmitAction: async (elem, selectedThread) => {\n\n    const thread = selectedThread\n\n    const send = async ( /** @type {string} */ nodeId) => {\n\n      /** @typedef {ResultData} */\n      const detail = [thread, {\n        checkpoint: (nodeId === 'start' || nodeId === 'stop') ? undefined : `checkpoint-${nodeId}`,\n        node: nodeId,\n        state: {\n          input: \"this is input\",\n          property1: { value: \"value1\", valid: true },\n          property2: { value: \"value2\", children: { elements: [1, 2, 3] } }\n        }\n      }]\n\n      /** @typedef {CustomEvent<ResultData>} */\n      const event = new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      });\n\n      await delay(1000);\n      elem.dispatchEvent(event);\n    }\n\n    await send('__START__');\n    await send('agent_describer');\n    await send('agent_generic_plantuml');\n    await send('___START__');\n    await send('_evaluate_result');\n    await send('___END__');\n    await send('__END__');\n\n  }\n\n}"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$hNeh9","$800sp","$fe8cbfd9ee8314da$var$delay","ms","Promise","resolve","setTimeout","$fe8cbfd9ee8314da$export$b5b93dd066d67af9","callInit","elem","detail","threads","title","args","name","type","required","graph","event","CustomEvent","bubbles","composed","cancelable","dispatchEvent","callSubmitAction","selectedThread","send","nodeId","checkpoint","undefined","node","state","input","property1","value","valid","property2","children","elements","$0ca21e1f1d158660$var$streamingResponse","response","reader","body","getReader","done","read","TextDecoder","decode","$0ca21e1f1d158660$export$2fe88ce002d9c04f","LitElement","styles","default","css","properties","url","String","reflect","test","Boolean","_executing","constructor","formMetaData","e","console","debug","requestUpdate","connectedCallback","addEventListener","then","data","disconnectedCallback","removeEventListener","render","html","map","initResponse","fetch","initData","json","execResponse","method","headers","JSON","stringify","chunk","parse","reduce","acc","md","shadowRoot","getElementById","window","customElements","define"],"version":3,"file":"index.19ba425e.js.map"}